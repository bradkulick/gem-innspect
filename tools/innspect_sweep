#!/usr/bin/env python3
import os
import subprocess
import re
import json
import socket
import struct
import time
import threading
import ipaddress

# --- Configuration & Data ---

def get_package_path():
    return os.path.dirname(os.path.dirname(os.path.realpath(__file__)))

def load_signatures():
    path = os.path.join(get_package_path(), "blueprints", "camera_signatures.json")
    try:
        with open(path, 'r') as f:
            return json.load(f)
    except Exception as e:
        return {"vendors": {}, "suspicious_ports": []}

SUSPICIOUS_VENDORS = load_signatures().get("vendors", {})

# --- Environment Detection ---

def is_virtualized():
    checks = []
    if os.path.exists("/.dockerenv"): checks.append("Docker")
    try:
        with open("/proc/1/cgroup", "r") as f:
            content = f.read()
            if "docker" in content: checks.append("Docker")
            if "lxc" in content: checks.append("LXC/LXD")
    except: pass
    try:
        res = subprocess.check_output(["systemd-detect-virt"], stderr=subprocess.DEVNULL).decode().strip()
        if res != "none": checks.append(res)
    except: pass
    try:
        res = subprocess.check_output(["ip", "neigh"]).decode()
        for line in res.splitlines():
            if "lladdr" in line:
                parts = line.split()
                mac = parts[parts.index("lladdr") + 1].upper()
                if mac.startswith("00:16:3E"): checks.append("Virtual Gateway MAC")
    except: pass
    return checks

# --- Active Scanning (ARP/Ping) ---

def get_my_ip_info():
    try:
        # Try to find the primary interface
        res = subprocess.check_output(["ip", "-o", "-4", "addr", "show", "up"]).decode()
        # Look for the first non-loopback address
        for line in res.splitlines():
            if " lo " in line: continue
            match = re.search(r"inet\s+(\d+\.\d+\.\d+\.\d+)/(\d+)", line)
            if match:
                return match.group(1), int(match.group(2))
    except: pass
    return None, None

def ping_host(ip):
    try:
        subprocess.call(["ping", "-c", "1", "-W", "1", str(ip)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except: pass

def active_scan():
    my_ip, cidr = get_my_ip_info()
    if not my_ip:
        print("[-] Active Scan: Could not determine network info.")
        return []

    network = ipaddress.IPv4Network(f"{my_ip}/{cidr}", strict=False)
    print(f"[*] Active Scan: Pinging {network}...")
    
    threads = []
    for ip in list(network.hosts())[:255]: # Safety limit
        if str(ip) == my_ip: continue
        t = threading.Thread(target=ping_host, args=(ip,))
        t.start()
        threads.append(t)
    for t in threads: t.join()

    results = []
    try:
        res = subprocess.check_output(["ip", "neigh"]).decode()
        for line in res.splitlines():
            parts = line.split()
            if len(parts) >= 5 and "lladdr" in parts:
                ip = parts[0]
                mac = parts[parts.index("lladdr") + 1].upper()
                results.append({"ip": ip, "mac": mac, "source": "ARP"})
    except: pass
    return results

# --- Passive Scanning (Multicast) ---

def passive_scan(timeout=5):
    print(f"[*] Passive Scan: Listening for mDNS/SSDP (Timeout: {timeout}s)...")
    devices = {}

    def scan_ssdp():
        addr, port = "239.255.255.250", 1900
        req = (f"M-SEARCH * HTTP/1.1\r\nHOST: {addr}:{port}\r\nMAN: \"ssdp:discover\"\r\nMX: 2\r\nST: ssdp:all\r\n\r\n").encode()
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(timeout)
            for _ in range(2): sock.sendto(req, (addr, port))
            start = time.time()
            while time.time() - start < timeout:
                try:
                    data, addr_info = sock.recvfrom(65535)
                    decoded = data.decode('utf-8', errors='ignore')
                    headers = {l.split(':', 1)[0].upper(): l.split(':', 1)[1].strip() for l in decoded.split('\r\n') if ':' in l}
                    server = headers.get('SERVER', 'Unknown')
                    devices[addr_info[0]] = {"info": f"SSDP: {server}", "source": "Multicast"}
                except socket.timeout: break
        except: pass

    def listen_mdns():
        addr, port = "224.0.0.251", 5353
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(("", port))
            sock.settimeout(timeout)
            start = time.time()
            while time.time() - start < timeout:
                try:
                    data, addr_info = sock.recvfrom(65535)
                    content = "".join([c if c.isprintable() else '.' for c in data.decode('utf-8', errors='ignore')])
                    matches = re.findall(r'[\w-]+\.local', content)
                    if matches:
                        existing = devices.get(addr_info[0], {"info": ""})
                        new_info = f"mDNS: {', '.join(set(matches))}"
                        devices[addr_info[0]] = {"info": f"{existing['info']} {new_info}".strip(), "source": "Multicast"}
                except socket.timeout: break
        except: pass

    t1 = threading.Thread(target=scan_ssdp)
    t2 = threading.Thread(target=listen_mdns)
    t1.start(); t2.start()
    t1.join(); t2.join()
    
    return [{"ip": ip, "info": d["info"], "source": d["source"]} for ip, d in devices.items()]

# --- Main Execution ---

def main():
    print("ðŸ’Ž InnSpect Unified Sweep")
    print("-" * 50)
    
    virt_issues = is_virtualized()
    if virt_issues:
        print("\033[93m[!] RESTRICTED ENVIRONMENT DETECTED\033[0m")
        print(f"    Detected: {', '.join(virt_issues)}")
        print("    Impact: Active ARP scanning will likely return no results.")
        print("    Strategy: Relying on Passive Multicast Discovery.")
        print("-" * 50)
        
    found_devices = {}

    # 1. Passive Scan (Always runs)
    p_results = passive_scan()
    for d in p_results:
        found_devices[d['ip']] = {"mac": "Unknown", "info": d['info'], "source": d['source']}

    # 2. Active Scan (Only useful if native, but we try anyway)
    a_results = active_scan()
    for d in a_results:
        if d['ip'] in found_devices:
            found_devices[d['ip']]["mac"] = d['mac']
        else:
            found_devices[d['ip']] = {"mac": d['mac'], "info": "No broadcast data", "source": d['source']}

    # 3. Report
    print(f"\nâœ… Found {len(found_devices)} Unique Devices")
    print(f"{ 'IP Address':<15} | { 'MAC Address':<17} | {'Assessment/Info'}")
    print("-" * 75)
    
    for ip, data in found_devices.items():
        mac = data['mac']
        info = data['info']
        prefix = mac[:8].upper()
        vendor = SUSPICIOUS_VENDORS.get(prefix, "")
        
        status = "\033[92mSafe\033[0m"
        if vendor:
            status = f"\033[91mSUSPICIOUS: {vendor}\033[0m"
        
        print(f"{ip:<15} | {mac:<17} | {status}")
        if info and info != "No broadcast data":
            print(f"    â””â”€ {info}")

    print("-" * 75)
    print("\nScan Complete. If results are empty, use a host device (phone) for a second opinion.")

if __name__ == "__main__":
    main()
